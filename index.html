<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Octahedron — 8 Face Cones (Φ‑Spiral Center‑Meeting)</title>
  <style>
    html, body { height:100%; margin:0; }
    body { background:#0b0e13; color:#e7eaee; font:14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position:fixed; inset:0; }
    .ui { position:fixed; top:12px; left:12px; background:rgba(12,20,30,.92); border:1px solid #233244; border-radius:12px; padding:12px; display:grid; gap:8px; min-width:480px; z-index:10 }
    .row { display:flex; align-items:center; gap:10px }
    .row label { flex:1; color:#9fb1c7 }
    .row input[type="range"], .row input[type="number"], .row select { flex:2 }
    .row input[type="checkbox"] { transform: translateY(1px) }
    .title { font-weight:600; color:#cde3ff; margin-bottom:4px }
    .pill { position:fixed; top:12px; right:12px; padding:6px 10px; border-radius:999px; border:1px solid #233244; background:#0e1622; color:#9fb1c7; cursor:pointer; user-select:none }
    a.small { color:#7ae0ff; text-decoration:none; cursor:pointer }
    .diag { font:12px/1.35 ui-sans-serif,system-ui; color:#9fb1c7; background:rgba(10,16,24,.7); border:1px solid #1b2838; border-radius:8px; padding:8px; white-space:pre-wrap }
    .mono { font:12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color:#cde3ff }
    .muted { opacity:.65 }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="ui" id="panel">
    <div class="title">Octahedron Implosion — Face Cones Only</div>

    <div class="row"><label>Show wireframe</label><input id="showWire" type="checkbox" checked></div>

    <div class="row"><label>Show face cones (8)</label><input id="showCones" type="checkbox" checked></div>
    <div class="row"><label>Show spirals on faces (×3)</label><input id="showSpirals" type="checkbox" checked></div>

    <div class="row"><label>Scale (octahedron)</label><div class="mono">1.670× (locked)</div></div>

    <div class="row"><label>Depth scale (faces)</label><input id="depthScale" type="range" min="0.5" max="1.5" step="0.01" value="1.00"></div>

    <div class="row"><label>Fit face bases to triangle edges</label><input id="fitEdges" type="checkbox" checked></div>

    <div class="row"><label>Cone radius (faces)</label><input id="coneRad" type="range" min="0.01" max="1.5" step="0.01" value="0.35"></div>

    <div class="row"><label>Face spiral thickness</label><input id="faceTubeR" type="range" min="0.003" max="0.2" step="0.002" value="0.025"></div>

    <div class="row"><label>Spiral base radius (when Fit is off)</label><input id="spiralR0" type="range" min="0.02" max="1.5" step="0.01" value="0.45"></div>
    <div class="row"><label>Spiral turns</label><input id="spiralTurns" type="range" min="0.5" max="8" step="0.1" value="3.0"></div>
    <div class="row"><label>Φ exponent</label><input id="phiPow" type="range" min="0.0" max="3.0" step="0.01" value="0.0"></div>

    <div class="row"><label>Animate torsion</label><input id="animate" type="checkbox" checked></div>
    <div class="row"><label>Face spiral spin (Top CW / Bottom CCW)</label><input id="faceSpin" type="range" min="0" max="3" step="0.01" value="0.8"></div>

    <div class="row muted"><small>With <b>Fit face bases</b> on, each face’s cone base & spiral start sit on the triangle inradius (touching edges). Turn it off to use the manual base radius.</small></div>
    <div class="row" style="justify-content:space-between"><a class="small" id="reset">reset view</a><a class="small" id="rebuild">rebuild</a><a class="small" id="runTests">run tests</a></div>
    <div class="diag" id="diag">Diagnostics will appear here after build.</div>
  </div>
  <div class="pill" id="toggle">hide UI</div>

  <!-- Three.js r146 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TubeGeometry.js"></script>

  <script>
    const PHI = (1 + Math.sqrt(5)) / 2;

    let scene, camera, renderer, controls, root, wire;
    let params;
    const faceGroups = [];
    const faceTop = [];
    const faceBottom = [];

    init();
    build();
    animate();

    function init(){
      const app = document.getElementById('app');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0e13);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 1000);
      camera.position.set(3.2, 2.1, 3.6);

      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      app.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
      const dir  = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,4,2);
      scene.add(hemi, dir);

      root = new THREE.Group();
      scene.add(root);

      params = {
        showWire: document.getElementById('showWire'),
        showCones: document.getElementById('showCones'),
        showSpirals: document.getElementById('showSpirals'),
        depthScale: document.getElementById('depthScale'),
        coneRad: document.getElementById('coneRad'),
        spiralR0: document.getElementById('spiralR0'),
        spiralTurns: document.getElementById('spiralTurns'),
        phiPow: document.getElementById('phiPow'),
        faceTubeR: document.getElementById('faceTubeR'),
        faceSpin: document.getElementById('faceSpin'),
        fitEdges: document.getElementById('fitEdges'),
        animate: document.getElementById('animate'),
      };

      const allInputs = [params.showWire, params.showCones, params.showSpirals,
        params.depthScale, params.coneRad, params.spiralR0, params.spiralTurns, params.phiPow,
        params.faceTubeR, params.faceSpin, params.fitEdges];
      allInputs.forEach(el=>{ if(el) el.addEventListener('input', debounce(rebuild, 0)); });

      document.getElementById('rebuild').addEventListener('click', rebuild);
      document.getElementById('runTests').addEventListener('click', runTests);
      document.getElementById('reset').addEventListener('click', ()=>{ controls.reset(); camera.position.set(3.2,2.1,3.6); });
      document.getElementById('toggle').addEventListener('click', ()=>{
        const panel = document.getElementById('panel');
        if(panel.style.display === 'none'){ panel.style.display = ''; document.getElementById('toggle').textContent='hide UI'; }
        else { panel.style.display = 'none'; document.getElementById('toggle').textContent='show UI'; }
      });

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function rebuild(){
      faceGroups.length = 0; faceTop.length = 0; faceBottom.length = 0;
      clearGroup(root);
      if(wire){ scene.remove(wire); dispose(wire); wire = null; }

      const scale = 1.67; // locked scale

      // Octahedron frame
      const geo = new THREE.OctahedronGeometry(scale, 0);
      const edges = new THREE.EdgesGeometry(geo);
      wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color:0x3a506b, transparent:true, opacity:0.8 }));
      if(params.showWire.checked) scene.add(wire);

      // --- Robust face iteration (indexed or non-indexed) ---
      const pos = geo.attributes.position;
      let triIndex;
      if(geo.index && geo.index.array && geo.index.array.length){
        triIndex = geo.index.array; // typed array
      } else {
        const count = pos.count;
        triIndex = new (count > 65535 ? Uint32Array : Uint16Array)(count);
        for(let i=0;i<count;i++) triIndex[i] = i;
      }

      // Materials
      const coneMat  = new THREE.MeshStandardMaterial({ color:0x88ccff, metalness:0.1, roughness:0.35, transparent:true, opacity:0.35, depthWrite:false });

      const showCones = params.showCones.checked;
      const showSpirals = params.showSpirals.checked;

      const depthScale = parseFloat(params.depthScale.value);
      const coneRadSlider = parseFloat(params.coneRad.value);
      const turns = parseFloat(params.spiralTurns.value);
      const phiPow = parseFloat(params.phiPow.value);
      const faceTubeR = parseFloat(params.faceTubeR.value);
      const fitEdges = !!(params.fitEdges && params.fitEdges.checked);
      const spiralR0 = parseFloat(params.spiralR0.value);

      let faceRefDepth = null;

      const groups = new THREE.Group();

      const facesFound = Math.floor(triIndex.length / 3);
      for(let f=0; f<facesFound*3; f+=3){
        const i0 = triIndex[f], i1 = triIndex[f+1], i2 = triIndex[f+2];
        const v0 = new THREE.Vector3().fromBufferAttribute(pos, i0);
        const v1 = new THREE.Vector3().fromBufferAttribute(pos, i1);
        const v2 = new THREE.Vector3().fromBufferAttribute(pos, i2);

        const centroid = new THREE.Vector3().addVectors(v0, v1).add(v2).multiplyScalar(1/3);

        const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).normalize();
        const w = n.clone().negate(); // inward

        const baseDepth = Math.max(0, -centroid.dot(w));
        const coneLen = baseDepth * depthScale;
        if(faceRefDepth === null) faceRefDepth = coneLen;

        // Inradius so base circle touches triangle edges
        const area = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).length() * 0.5;
        const s0 = v1.clone().sub(v0).length();
        const s1 = v2.clone().sub(v1).length();
        const s2 = v0.clone().sub(v2).length();
        const perim = s0 + s1 + s2;
        const rin = (2 * area) / perim; // inradius
        const RING_EPS = 1e-4;

        const coneRadFace = fitEdges ? rin * (1 - RING_EPS) : coneRadSlider;
        const spiralR0Face = fitEdges ? rin * (1 - RING_EPS) : spiralR0;

        const faceGroup = new THREE.Group();
        faceGroup.position.copy(centroid);
        const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), w);
        faceGroup.quaternion.copy(quat);
        faceGroup.userData.rIn = rin;
        faceGroup.userData.coneRadUsed = coneRadFace;
        faceGroup.userData.spiralR0Used = spiralR0Face;

        if(showCones){
          const coneGeo = new THREE.ConeGeometry(coneRadFace, coneLen, 48, 1, true);
          const cone = new THREE.Mesh(coneGeo, coneMat);
          cone.rotation.x = Math.PI/2;
          cone.position.z = coneLen/2;
          faceGroup.add(cone);
        }

        if(showSpirals){
          for(let k=0; k<3; k++){
            const phase = k * (2*Math.PI/3);
            const curve = makePhiSpiralCurve(spiralR0Face, turns, phiPow, coneLen, phase);
            const tubeGeo = new THREE.TubeGeometry(curve, 240, faceTubeR, 8, false);
            const mat = new THREE.MeshStandardMaterial({ metalness:0.1, roughness:0.35, vertexColors:true });
            colorizeTube(tubeGeo, vividRainbow);
            const tube = new THREE.Mesh(tubeGeo, mat);
            faceGroup.add(tube);
          }
        }

        groups.add(faceGroup);
        faceGroups.push(faceGroup);
        if(centroid.y >= 0) faceTop.push(faceGroup); else faceBottom.push(faceGroup);
      }

      root.add(groups);

      updateDiagnostics({
        idxPresent: !!(geo.index && geo.index.array && geo.index.array.length),
        posCount: pos.count,
        triCount: triIndex.length,
        faceCount: Math.floor(triIndex.length/3),
        faceRefDepth: faceRefDepth
      });
    }

    // Spiral parametric curve (local coords)
    function makePhiSpiralCurve(r0, turns, phiPow, depth, phase){
      const totalTheta = turns * 2*Math.PI;
      const a = Math.log(PHI) * (phiPow <= 0 ? 0 : phiPow);
      class PhiSpiralCurve extends THREE.Curve {
        getPoint(t){
          const theta = t * totalTheta + phase;
          const shrink = Math.exp(-a * t);
          const r = r0 * shrink * (1 - t); // zero at t=1 -> exact center
          const x = r * Math.cos(theta);
          const y = r * Math.sin(theta);
          const z = t * depth;
          return new THREE.Vector3(x, y, z);
        }
      }
      return new PhiSpiralCurve();
    }

    // Color gradients
    function vividRainbow(t){ // 0 outer -> 1 center
      const h = (1.0 - t) * 360;
      const s = 1.0, v = 1.0;
      return hsv2rgb(h, s, v);
    }
    function hsv2rgb(h, s, v){
      const c = v*s; const x = c * (1 - Math.abs(((h/60)%2) - 1)); const m = v - c;
      let r=0,g=0,b=0;
      if(h<60){ r=c; g=x; b=0; } else if(h<120){ r=x; g=c; b=0; } else if(h<180){ r=0; g=c; b=x; }
      else if(h<240){ r=0; g=x; b=c; } else if(h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
      return [r+m, g+m, b+m];
    }

    function colorizeTube(geo, paletteFn){
      const ts = geo.parameters.tubularSegments;
      const rs = geo.parameters.radialSegments;
      const posCount = geo.attributes.position.count; // (ts+1)*(rs+1)
      const colors = new Float32Array(posCount * 3);
      for(let i=0;i<=ts;i++){
        const t = i/ts;
        const [r,g,b] = paletteFn(t);
        for(let j=0;j<=rs;j++){
          const idx = (i*(rs+1) + j)*3;
          colors[idx] = r; colors[idx+1] = g; colors[idx+2] = b;
        }
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.attributes.color.needsUpdate = true;
    }

    function runTests(){
      const out = [];
      const ok=(m)=>out.push('✔ '+m), warn=(m)=>out.push('⚠ '+m), err=(m)=>out.push('✖ '+m);
      try{
        rebuild();
        const diag = JSON.parse(document.getElementById('diag').dataset.json || '{}');
        const faceCount = diag.faceCount;
        if(faceCount===8) ok('Octahedron has 8 faces.'); else err('Faces != 8');
        const tf = (typeof faceTop!== 'undefined') ? faceTop.length : 0;
        const bf = (typeof faceBottom!== 'undefined') ? faceBottom.length : 0;
        if(tf===4 && bf===4) ok('Top/bottom faces classified 4/4 for counter-rotation.'); else warn(`Top/bottom classification is ${tf}/${bf} (expected 4/4).`);
        if(typeof THREE.TubeGeometry==='function') ok('TubeGeometry available.'); else err('TubeGeometry missing');

        // Fit-to-edges tests
        if(params.fitEdges && params.fitEdges.checked){
          const groups = root.children[0];
          const faces = groups.children; // all are faces
          const EPS = 1e-4;
          if(faces.length){
            const g = faces[0];
            const cone = g.children.find(ch=>ch.geometry && ch.geometry.type==='ConeGeometry');
            if(cone){ Math.abs(cone.geometry.parameters.radius - g.userData.coneRadUsed) < EPS ? ok('Face cone base = inradius (±ε).') : err('Face cone base ≠ inradius.'); }
            const tube = g.children.find(ch=>ch.geometry && ch.geometry.type==='TubeGeometry');
            if(tube && tube.geometry.parameters && tube.geometry.parameters.path){
              const start = tube.geometry.parameters.path.getPoint(0); const r0 = Math.hypot(start.x, start.y);
              Math.abs(r0 - g.userData.spiralR0Used) < EPS ? ok('Face spiral starts at inradius (±ε).') : err('Face spiral start ≠ inradius.');
            }
          }
        } else { warn('Fit-to-edges disabled — skipped inradius tests.'); }
      }catch(e){ console.error(e); err('Tests threw: '+e.message); }
      document.getElementById('diag').textContent = out.join('\n');
    }

    function updateDiagnostics(info){
      const diag = document.getElementById('diag');
      diag.dataset.json = JSON.stringify(info);
      const lines = [];
      lines.push(`Index present: ${info.idxPresent}`);
      lines.push(`position.count: ${info.posCount}`);
      lines.push(`triIndex length: ${info.triCount}`);
      lines.push(`faces found: ${info.faceCount}`);
      lines.push(`faceRefDepth: ${info.faceRefDepth?.toFixed ? info.faceRefDepth.toFixed(4) : info.faceRefDepth}`);
      diag.textContent = lines.join('\n');
    }

    function clearGroup(g){ while(g.children.length){ const c=g.children.pop(); dispose(c); } }

    function dispose(obj){
      obj.traverse(o=>{
        if(o.geometry){ o.geometry.dispose && o.geometry.dispose(); }
        if(o.material){
          if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose());
          else o.material.dispose && o.material.dispose();
        }
      });
    }

    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), ms); }; }

    function build(){ rebuild(); }

    function animate(){
      requestAnimationFrame(animate);

      const faceSpeed = Math.abs(parseFloat(params.faceSpin.value)) * 0.01; // magnitude
      for(const g of faceTop){ g.rotation.z -= faceSpeed; }
      for(const g of faceBottom){ g.rotation.z += faceSpeed; }

      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
