<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Platonic Solids / Star Tetra — True Faces (Φ‑Spiral Center‑Meeting)</title>
  <style>
    html, body { height:100%; margin:0; }
    body { background:#0b0e13; color:#e7eaee; font:14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position:fixed; inset:0; }
    .ui { position:fixed; top:12px; left:12px; background:rgba(12,20,30,.92); border:1px solid #233244; border-radius:12px; padding:12px; display:grid; gap:8px; min-width:600px; z-index:10 }
    .row { display:flex; align-items:center; gap:10px }
    .row label { flex:1; color:#9fb1c7 }
    .row input[type="range"], .row input[type="number"], .row select { flex:2 }
    .row input[type="checkbox"] { transform: translateY(1px) }
    .title { font-weight:600; color:#cde3ff; margin-bottom:4px }
    .pill { position:fixed; top:12px; right:12px; padding:6px 10px; border-radius:999px; border:1px solid #233244; background:#0e1622; color:#9fb1c7; cursor:pointer; user-select:none }
    a.small { color:#7ae0ff; text-decoration:none; cursor:pointer }
    .diag { font:12px/1.35 ui-sans-serif,system-ui; color:#9fb1c7; background:rgba(10,16,24,.7); border:1px solid #1b2838; border-radius:8px; padding:8px; white-space:pre-wrap }
    .mono { font:12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color:#cde3ff }
    .muted { opacity:.65 }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="ui" id="panel">
    <div class="title">Platonic Solids — face cones + 3 φ‑spirals (center‑meeting)</div>

    <div class="row"><label>Solid</label>
      <select id="poly">
        <option value="tetra">Tetrahedron (4 faces)</option>
        <option value="cube">Cube (6 faces)</option>
        <option value="octa" selected>Octahedron (8 faces)</option>
        <option value="dodeca">Dodecahedron (12 faces)</option>
        <option value="icosa">Icosahedron (20 faces)</option>
        <option value="star">Star tetrahedron (compound, 8 faces)</option>
      </select>
    </div>

    <div class="row"><label>Show wireframe</label><input id="showWire" type="checkbox" checked></div>

    <div class="row"><label>Show face cones</label><input id="showCones" type="checkbox" checked></div>
    <div class="row"><label>Show spirals on faces (×3)</label><input id="showSpirals" type="checkbox" checked></div>

    <div class="row"><label>Scale (solid)</label><div class="mono">1.670× (locked)</div></div>

    <div class="row"><label>Depth scale (faces)</label><input id="depthScale" type="range" min="0.5" max="1.5" step="0.01" value="1.00"></div>

    <div class="row"><label>Fit face bases to edges</label><input id="fitEdges" type="checkbox" checked></div>

    <div class="row"><label>Cone radius (faces)</label><input id="coneRad" type="range" min="0.01" max="1.5" step="0.01" value="0.35"></div>

    <div class="row"><label>Face spiral thickness</label><input id="faceTubeR" type="range" min="0.003" max="0.2" step="0.002" value="0.003"></div>

    <div class="row"><label>Spiral base radius (when Fit is off)</label><input id="spiralR0" type="range" min="0.02" max="1.5" step="0.01" value="0.45"></div>
    <div class="row"><label>Spiral turns</label><input id="spiralTurns" type="range" min="0.5" max="8" step="0.1" value="3.0"></div>
    <div class="row"><label>Φ exponent</label><input id="phiPow" type="range" min="0.0" max="3.0" step="0.01" value="0.0"></div>

    <div class="row"><label>Animate torsion</label><input id="animate" type="checkbox" checked></div>
    <div class="row"><label>Spin speed</label><input id="faceSpin" type="range" min="0" max="9" step="0.01" value="4.5"></div>
    <div class="row"><label>Spin direction</label>
      <select id="spinDir">
        <option value="cw" selected>Clockwise</option>
        <option value="ccw">Counter‑clockwise</option>
      </select>
    </div>

    <div class="row muted"><small><b>Faces, not triangles:</b> cube=6 squares, dodeca=12 pentagons. Cones & spirals now sized using each true face’s apothem (inradius), so bases <em>kiss</em> the edges.</small></div>
    <div class="row" style="justify-content:space-between"><a class="small" id="reset">reset view</a><a class="small" id="rebuild">rebuild</a><a class="small" id="runTests">run tests</a></div>
    <div class="diag" id="diag">Diagnostics will appear here after build.</div>
  </div>
  <div class="pill" id="toggle">hide UI</div>

  <!-- Three.js r146 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TubeGeometry.js"></script>

  <script>
    const PHI = (1 + Math.sqrt(5)) / 2;

    let scene, camera, renderer, controls, root, wire;
    let params;
    const faceGroups = [];

    init();
    build();
    animate();

    function init(){
      const app = document.getElementById('app');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0e13);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 1000);
      camera.position.set(3.2, 2.1, 3.6);

      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      app.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
      const dir  = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,4,2);
      scene.add(hemi, dir);

      root = new THREE.Group();
      scene.add(root);

      params = {
        poly: document.getElementById('poly'),
        showWire: document.getElementById('showWire'),
        showCones: document.getElementById('showCones'),
        showSpirals: document.getElementById('showSpirals'),
        depthScale: document.getElementById('depthScale'),
        coneRad: document.getElementById('coneRad'),
        spiralR0: document.getElementById('spiralR0'),
        spiralTurns: document.getElementById('spiralTurns'),
        phiPow: document.getElementById('phiPow'),
        faceTubeR: document.getElementById('faceTubeR'),
        faceSpin: document.getElementById('faceSpin'),
        spinDir: document.getElementById('spinDir'),
        fitEdges: document.getElementById('fitEdges'),
        animate: document.getElementById('animate'),
      };

      const allInputs = [params.poly, params.showWire, params.showCones, params.showSpirals,
        params.depthScale, params.coneRad, params.spiralR0, params.spiralTurns, params.phiPow,
        params.faceTubeR, params.faceSpin, params.spinDir, params.fitEdges];
      allInputs.forEach(el=>{ if(el) el.addEventListener('input', debounce(rebuild, 0)); });

      document.getElementById('rebuild').addEventListener('click', rebuild);
      document.getElementById('runTests').addEventListener('click', runTests);
      document.getElementById('reset').addEventListener('click', ()=>{ controls.reset(); camera.position.set(3.2,2.1,3.6); });
      document.getElementById('toggle').addEventListener('click', ()=>{
        const panel = document.getElementById('panel');
        if(panel.style.display === 'none'){ panel.style.display = ''; document.getElementById('toggle').textContent='hide UI'; }
        else { panel.style.display = 'none'; document.getElementById('toggle').textContent='show UI'; }
      });

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function getGeometry(kind, scale){
      switch(kind){
        case 'tetra': return new THREE.TetrahedronGeometry(scale, 0);
        case 'cube': return new THREE.BoxGeometry(scale*2, scale*2, scale*2, 1, 1, 1); // triangulated; we'll merge triangles per face
        case 'octa': return new THREE.OctahedronGeometry(scale, 0);
        case 'dodeca': return new THREE.DodecahedronGeometry(scale, 0); // triangulated; we'll merge per pentagon
        case 'icosa': return new THREE.IcosahedronGeometry(scale, 0);
        case 'star': return buildStarTetraGeometry(scale);
        default: return new THREE.IcosahedronGeometry(scale, 0);
      }
    }

    function rebuild(){
      faceGroups.length = 0;
      clearGroup(root);
      if(wire){ scene.remove(wire); dispose(wire); wire = null; }

      const scale = 1.67; // locked scale
      const solid = params.poly.value;

      // Frame
      const geo = getGeometry(solid, scale);
      const edges = new THREE.EdgesGeometry(geo);
      wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color:0x3a506b, transparent:true, opacity:0.8 }));
      if(params.showWire.checked) scene.add(wire);

      // Robust face iteration: group coplanar triangles into true faces
      const faces = groupGeometryFaces(geo);

      // Materials
      const coneMat  = new THREE.MeshStandardMaterial({ color:0x88ccff, metalness:0.1, roughness:0.35, transparent:true, opacity:0.35, depthWrite:false });

      const showCones = params.showCones.checked;
      const showSpirals = params.showSpirals.checked;

      const depthScale = parseFloat(params.depthScale.value);
      const coneRadSlider = parseFloat(params.coneRad.value);
      const turns = parseFloat(params.spiralTurns.value);
      const phiPow = parseFloat(params.phiPow.value);
      const faceTubeR = parseFloat(params.faceTubeR.value);
      const fitEdges = !!(params.fitEdges && params.fitEdges.checked);
      const spiralR0 = parseFloat(params.spiralR0.value);

      const groups = new THREE.Group();

      faces.forEach(face=>{
        const { n, verts3, center3 } = face; // verts3: unique 3D vertices of this polygon (unordered)
        // Build local 2D frame in face plane
        const u = pickPerp(n).cross(n).normalize();
        const v = n.clone().cross(u).normalize();
        const verts2 = verts3.map(p=> new THREE.Vector2(p.dot(u), p.dot(v)) );
        const c2 = verts2.reduce((acc,p)=>acc.add(p), new THREE.Vector2()).multiplyScalar(1/verts2.length);
        // Order polygon CCW around center in 2D
        const idx = verts2.map((p,i)=>({i, ang:Math.atan2(p.y - c2.y, p.x - c2.x)})).sort((a,b)=>a.ang-b.ang).map(o=>o.i);
        const ordered2 = idx.map(i=>verts2[i]);

        const N = ordered2.length; // 3,4,5, etc.
        // Average edge length in 2D
        let avgS = 0; for(let i=0;i<N;i++){ const a=ordered2[i], b=ordered2[(i+1)%N]; avgS += a.distanceTo(b); } avgS/=N;
        // Apothem (inradius) of regular N-gon from edge length s
        const apothem = avgS / (2 * Math.tan(Math.PI / N));
        const RING_EPS = 1e-4;
        const baseRadius = fitEdges ? apothem * (1 - RING_EPS) : coneRadSlider;
        const spiralR0Face = fitEdges ? apothem * (1 - RING_EPS) : spiralR0;

        // Plane distance to origin (face-to-center along normal)
        const planeDist = Math.abs(center3.dot(n));
        const coneLen = planeDist * depthScale;

        // Build face group at 3D center with inward axis = +Z in local
        const faceGroup = new THREE.Group();
        faceGroup.position.copy(center3);
        const w = n.clone().negate(); // inward
        const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), w);
        faceGroup.quaternion.copy(quat);

        faceGroup.userData.N = N;
        faceGroup.userData.apothem = apothem;
        faceGroup.userData.coneRadUsed = baseRadius;
        faceGroup.userData.spiralR0Used = spiralR0Face;

        if(showCones){
          const coneGeo = new THREE.ConeGeometry(baseRadius, coneLen, 64, 1, true);
          const cone = new THREE.Mesh(coneGeo, coneMat);
          cone.rotation.x = Math.PI/2;
          cone.position.z = coneLen/2;
          faceGroup.add(cone);
        }

        if(showSpirals){
          for(let k=0;k<3;k++){
            const phase = k * (2*Math.PI/3);
            const curve = makePhiSpiralCurve(spiralR0Face, turns, phiPow, coneLen, phase);
            const tubeGeo = new THREE.TubeGeometry(curve, 240, faceTubeR, 8, false);
            const mat = new THREE.MeshStandardMaterial({ metalness:0.1, roughness:0.35, vertexColors:true });
            colorizeTube(tubeGeo, vividRainbow);
            const tube = new THREE.Mesh(tubeGeo, mat);
            faceGroup.add(tube);
          }
        }

        groups.add(faceGroup);
        faceGroups.push(faceGroup);
      });

      root.add(groups);

      updateDiagnostics({
        solid,
        faceCount: faces.length,
      });
    }

    // Group triangles of a BufferGeometry into coplanar faces and return face descriptors
    function groupGeometryFaces(geo){
      const pos = geo.attributes.position;
      // Build triangle indices (support non-indexed)
      let triIndex;
      if(geo.index && geo.index.array && geo.index.array.length){
        triIndex = geo.index.array;
      } else {
        const count = pos.count; triIndex = new (count>65535?Uint32Array:Uint16Array)(count);
        for(let i=0;i<count;i++) triIndex[i]=i;
      }

      const groupsMap = new Map();
      const tmpV = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
      for(let t=0; t<triIndex.length; t+=3){
        const i0=triIndex[t], i1=triIndex[t+1], i2=triIndex[t+2];
        const v0 = tmpV[0].fromBufferAttribute(pos, i0).clone();
        const v1 = tmpV[1].fromBufferAttribute(pos, i1).clone();
        const v2 = tmpV[2].fromBufferAttribute(pos, i2).clone();
        const c = v0.clone().add(v1).add(v2).multiplyScalar(1/3);
        let n = v1.clone().sub(v0).cross(v2.clone().sub(v0));
        if(c.dot(n) < 0) n.negate(); // make outward
        n.normalize();
        const d = n.dot(v0);
        const key = `${q(n.x)}_${q(n.y)}_${q(n.z)}_${q(d)}`; // quantized plane key
        if(!groupsMap.has(key)) groupsMap.set(key, { n:n.clone(), verts:[], d });
        const g = groupsMap.get(key);
        g.verts.push(v0.clone(), v1.clone(), v2.clone());
      }

      // Dedup vertices in each group and compute center
      const faces=[];
      groupsMap.forEach(g=>{
        const uniq = dedupeVec3(g.verts, 1e-6);
        const center3 = uniq.reduce((acc,p)=>acc.add(p), new THREE.Vector3()).multiplyScalar(1/uniq.length);
        faces.push({ n:g.n.clone(), verts3:uniq, center3 });
      });
      return faces;
    }

    // Helpers
    function q(x){ return Math.round(x*10000)/10000; }
    function pickPerp(n){
      // choose any vector not parallel to n
      const ax = Math.abs(n.x), ay=Math.abs(n.y), az=Math.abs(n.z);
      if(ax <= ay && ax <= az) return new THREE.Vector3(1,0,0);
      if(ay <= ax && ay <= az) return new THREE.Vector3(0,1,0);
      return new THREE.Vector3(0,0,1);
    }

    function dedupeVec3(arr, eps){
      const out=[];
      outer: for(const v of arr){
        for(const u of out){ if(v.distanceToSquared(u) < eps*eps){ continue outer; } }
        out.push(v.clone());
      }
      return out;
    }

    // Star tetra geometry (two tets) with outward faces
    function buildStarTetraGeometry(scale){
      const even = [
        new THREE.Vector3( 1, 1, 1),
        new THREE.Vector3(-1,-1, 1),
        new THREE.Vector3(-1, 1,-1),
        new THREE.Vector3( 1,-1,-1),
      ].map(v=>v.normalize().multiplyScalar(scale));
      const odd = [
        new THREE.Vector3( 1, 1,-1),
        new THREE.Vector3( 1,-1, 1),
        new THREE.Vector3(-1, 1, 1),
        new THREE.Vector3(-1,-1,-1),
      ].map(v=>v.normalize().multiplyScalar(scale));

      const facesIdx = [[0,1,2],[0,1,3],[0,2,3],[1,2,3]]; // 4 faces per tet
      const tris = [];
      const pushTet = (verts)=>{
        for(const [a,b,c] of facesIdx){
          const v0 = verts[a].clone();
          const v1 = verts[b].clone();
          const v2 = verts[c].clone();
          const centroid = v0.clone().add(v1).add(v2).multiplyScalar(1/3);
          let n = v1.clone().sub(v0).cross(v2.clone().sub(v0));
          if(centroid.dot(n) < 0){ // ensure outward
            tris.push(v0, v2, v1);
          } else {
            tris.push(v0, v1, v2);
          }
        }
      };
      pushTet(even); pushTet(odd);

      const pos = new Float32Array(tris.length * 3);
      for(let i=0;i<tris.length;i++){
        pos[i*3+0]=tris[i].x; pos[i*3+1]=tris[i].y; pos[i*3+2]=tris[i].z;
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.computeVertexNormals();
      return geo;
    }

    // Spiral curve in local coords (Z inward)
    function makePhiSpiralCurve(r0, turns, phiPow, depth, phase){
      const totalTheta = turns * 2*Math.PI;
      const a = Math.log(PHI) * (phiPow <= 0 ? 0 : phiPow);
      class PhiSpiralCurve extends THREE.Curve {
        getPoint(t){
          const theta = t * totalTheta + phase;
          const shrink = Math.exp(-a * t);
          const r = r0 * shrink * (1 - t); // zero at t=1 -> exact center
          const x = r * Math.cos(theta);
          const y = r * Math.sin(theta);
          const z = t * depth;
          return new THREE.Vector3(x, y, z);
        }
      }
      return new PhiSpiralCurve();
    }

    // Color gradient (vivid rainbow)
    function vividRainbow(t){ // 0 outer -> 1 center
      const h = (1.0 - t) * 360;
      const s = 1.0, v = 1.0;
      return hsv2rgb(h, s, v);
    }
    function hsv2rgb(h, s, v){
      const c = v*s; const x = c * (1 - Math.abs(((h/60)%2) - 1)); const m = v - c;
      let r=0,g=0,b=0;
      if(h<60){ r=c; g=x; b=0; } else if(h<120){ r=x; g=c; b=0; } else if(h<180){ r=0; g=c; b=x; }
      else if(h<240){ r=0; g=x; b=c; } else if(h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
      return [r+m, g+m, b+m];
    }

    function colorizeTube(geo, paletteFn){
      const ts = geo.parameters.tubularSegments;
      const rs = geo.parameters.radialSegments;
      const posCount = geo.attributes.position.count; // (ts+1)*(rs+1)
      const colors = new Float32Array(posCount * 3);
      for(let i=0;i<=ts;i++){
        const t = i/ts;
        const [r,g,b] = paletteFn(t);
        for(let j=0;j<=rs;j++){
          const idx = (i*(rs+1) + j)*3;
          colors[idx] = r; colors[idx+1] = g; colors[idx+2] = b;
        }
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.attributes.color.needsUpdate = true;
    }

    function runTests(){
      const out = [];
      const ok=(m)=>out.push('✔ '+m), warn=(m)=>out.push('⚠ '+m), err=(m)=>out.push('✖ '+m);
      try{
        rebuild();
        const diag = JSON.parse(document.getElementById('diag').dataset.json || '{}');
        const { solid, faceCount } = diag;
        const expected = { tetra:4, cube:6, octa:8, dodeca:12, icosa:20, star:8 };
        if(expected[solid]===faceCount) ok(`${capitalize(solid)} faces = ${faceCount}.`); else err(`${capitalize(solid)} faces = ${faceCount} (expected ${expected[solid]}).`);

        // Basic color/tube check
        if(typeof THREE.TubeGeometry==='function') ok('TubeGeometry available.'); else err('TubeGeometry missing');

        // Face apothem fit test (first face)
        const groups = root.children[0];
        if(groups && groups.children.length){
          const g = groups.children[0];
          const cone = g.children.find(ch=>ch.geometry && ch.geometry.type==='ConeGeometry');
          const tube = g.children.find(ch=>ch.geometry && ch.geometry.type==='TubeGeometry');
          const EPS = 1e-3;
          if(cone && g.userData){ Math.abs(cone.geometry.parameters.radius - g.userData.coneRadUsed) < EPS ? ok('Cone base = face apothem (±ε).') : err('Cone base ≠ face apothem.'); }
          if(tube && tube.geometry.parameters && tube.geometry.parameters.path){
            const start = tube.geometry.parameters.path.getPoint(0); const r0 = Math.hypot(start.x, start.y);
            Math.abs(r0 - g.userData.spiralR0Used) < EPS ? ok('Spiral start = face apothem (±ε).') : err('Spiral start ≠ face apothem.');
          }
        }
      }catch(e){ console.error(e); err('Tests threw: '+e.message); }
      document.getElementById('diag').textContent = out.join('\n');
    }

    function updateDiagnostics(info){
      const diag = document.getElementById('diag');
      const solid = params.poly.value;
      info.solid = solid;
      diag.dataset.json = JSON.stringify(info);
      const lines = [];
      lines.push(`Solid: ${solid}`);
      lines.push(`Faces: ${info.faceCount}`);
      diag.textContent = lines.join('\n');
    }

    function clearGroup(g){ while(g.children.length){ const c=g.children.pop(); dispose(c); } }

    function dispose(obj){
      obj.traverse(o=>{
        if(o.geometry){ o.geometry.dispose && o.geometry.dispose(); }
        if(o.material){
          if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose());
          else o.material.dispose && o.material.dispose();
        }
      });
    }

    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), ms); }; }

    function capitalize(s){ return s.charAt(0).toUpperCase()+s.slice(1); }

    function build(){ rebuild(); }

    function animate(){
      requestAnimationFrame(animate);

      const mag = Math.abs(parseFloat(params.faceSpin.value)) * 0.01; // magnitude
      const dir = params.spinDir.value === 'cw' ? -1 : +1;
      const speed = mag * dir;
      for(const g of faceGroups){ g.rotation.z += speed; }

      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
